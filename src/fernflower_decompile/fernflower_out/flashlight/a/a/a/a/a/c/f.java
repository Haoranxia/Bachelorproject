package a.a.a.a.a.c;

import java.util.Collection;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;

public abstract class f extends a.a.a.a.a.c.a implements a.a.a.a.a.c.b, i, l {
   private final j a;

   public f() {
      // $FF: Couldn't be decompiled
   }

   public void a(l param1) {
      // $FF: Couldn't be decompiled
   }

   public void a(Throwable param1) {
      // $FF: Couldn't be decompiled
   }

   public final void a(ExecutorService param1, Object... param2) {
      // $FF: Couldn't be decompiled
   }

   public a.a.a.a.a.c.e b() {
      // $FF: Couldn't be decompiled
   }

   public void b(boolean param1) {
      // $FF: Couldn't be decompiled
   }

   public Collection c() {
      // $FF: Couldn't be decompiled
   }

   // $FF: synthetic method
   public void c(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public int compareTo(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public boolean d() {
      // $FF: Couldn't be decompiled
   }

   public boolean f() {
      // $FF: Couldn't be decompiled
   }

   public a.a.a.a.a.c.b g() {
      // $FF: Couldn't be decompiled
   }

   private static class a implements Executor {
      private final Executor a;
      private final f b;

      public a(Executor param1, f param2) {
         // $FF: Couldn't be decompiled
      }

      // $FF: synthetic method
      static f a(f.a param0) {
         // $FF: Couldn't be decompiled
      }

      public void execute(Runnable param1) {
         // $FF: Couldn't be decompiled
      }
   }
}
